package main

// @title Swagger Example API
// @version 1.0
// @description This is a sample server celler server.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

import (
	"log"
	"os"
	"time"

	"github.com/dvwright/xss-mw"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	"github.com/penglongli/gin-metrics/ginmetrics"
	ginSwagger "github.com/swaggo/gin-swagger"
	"github.com/swaggo/gin-swagger/swaggerFiles"

	// docs is generated by Swag CLI, you have to import it.

	"prakticas/backend-gpsoft/docs"
	"prakticas/backend-gpsoft/src/internal/core/domain"
	authsrv "prakticas/backend-gpsoft/src/internal/core/services/auth-srv"
	cachesrv "prakticas/backend-gpsoft/src/internal/core/services/cache-srv"
	encryptionsrv "prakticas/backend-gpsoft/src/internal/core/services/encryption-srv"
	fieldssrv "prakticas/backend-gpsoft/src/internal/core/services/fields-srv"
	newssrv "prakticas/backend-gpsoft/src/internal/core/services/news-srv"
	userssrv "prakticas/backend-gpsoft/src/internal/core/services/users-srv"
	agroslabrepo "prakticas/backend-gpsoft/src/internal/dataSources/agroslab-repo"
	cacherepo "prakticas/backend-gpsoft/src/internal/dataSources/cache-repo"
	encryptionrepo "prakticas/backend-gpsoft/src/internal/dataSources/encryption-repo"
	newsrepo "prakticas/backend-gpsoft/src/internal/dataSources/news-repo"
	usersrepo "prakticas/backend-gpsoft/src/internal/dataSources/users-repo"
	fieldshdl "prakticas/backend-gpsoft/src/internal/handlers/fields-hdl"
	newshdl "prakticas/backend-gpsoft/src/internal/handlers/news-hdl"
	usershdl "prakticas/backend-gpsoft/src/internal/handlers/users-hdl"
	encryptionmw "prakticas/backend-gpsoft/src/middleware/encryption-mw"
	jwtmw "prakticas/backend-gpsoft/src/middleware/jwt-mw"

	cache "github.com/chenyahui/gin-cache"
	"github.com/chenyahui/gin-cache/persist"
)

func CorsConfig() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", os.Getenv("CLIENT_URI"))
		c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, GET, PATCH, DELETE")
		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}
		c.Next()
	}
}

func setUpMonitoring(r *gin.Engine) *gin.Engine {
	m := gin.Default()
	metrics := ginmetrics.GetMonitor()
	metrics.UseWithoutExposingEndpoint(r)
	metrics.Expose(m)
	return m
}

func setupRouter() *gin.Engine {

	mongoUri := os.Getenv("MONGO_URI")
	mongoDb := os.Getenv("MONGO_DB")
	redisUri := os.Getenv("REDIS_URI")
	encKey := os.Getenv("KEY_DECRYPT_PASSWD")
	ivKey := os.Getenv("IV_BLOCK_PASSWD")
	agroslabGeoUri := os.Getenv("AGROSLAB_GEO_URI")
	// agroslabTeleUri := os.Getenv("AGROSLAB_TELE_URI")
	agroslabAuthToken := os.Getenv("AGROSLAB_AUTH_TOKEN")

	encryptionrepository := encryptionrepo.NewEncrypter(encKey, ivKey)
	encryptionService := encryptionsrv.New(encryptionrepository)
	encryptionMiddleware := encryptionmw.Init(encryptionService)

	newsrepository := newsrepo.NewMongodbConn(mongoUri, mongoDb, 15)
	newsService := newssrv.New(newsrepository)
	newsHandler := newshdl.NewHTTPHandler(newsService)

	usersrespository := usersrepo.NewMongodbConn(mongoUri, mongoDb, 15)
	usersService := userssrv.New(usersrespository)
	usersHandler := usershdl.NewHTTPHandler(usersService)

	fieldsHTTPRepository := agroslabrepo.NewHttpConn(agroslabGeoUri, agroslabAuthToken)
	fieldsMongoRepository := agroslabrepo.NewMongodbConn(mongoUri, mongoDb, 15)
	fieldsAemetRepository := agroslabrepo.NewAemetHttpConn(agroslabGeoUri, agroslabAuthToken)
	fieldsService := fieldssrv.New(fieldsHTTPRepository, fieldsMongoRepository, fieldsAemetRepository)
	fieldsHandler := fieldshdl.NewHTTPHandler(fieldsService)

	cacherepository := cacherepo.NewRedisConn(redisUri)
	cacheService := cachesrv.New(cacherepository)
	authService := authsrv.JWTAuthService(cacheService)
	authMiddleware := jwtmw.Init(authService, usersService)

	cacheMiddleware := cache.CacheByRequestURI(persist.NewRedisStore(cacherepository.GetClient()), 10*time.Minute)

	r := gin.Default()
	m := ginmetrics.GetMonitor()
	m.SetMetricPath("/metrics")
	m.Use(r)
	r.SetTrustedProxies([]string{"localhost"})
	r.Use(CorsConfig())
	var xssMdlwr xss.XssMw
	r.Use(xssMdlwr.RemoveXss())

	r.GET("/ping", func(c *gin.Context) {
		c.String(200, "pong")
	})

	// ---- Auth
	r.POST("/auth/login", encryptionMiddleware.DecryptData, usersHandler.CheckLogin, authMiddleware.ReturnJWT)
	r.POST("/auth/logout", authMiddleware.RevokeJWT)
	r.POST("/auth/refresh", authMiddleware.RefreshJWT)
	r.POST("/auth/validate", authMiddleware.AuthorizeJWT([]string{domain.Admin, domain.Agrarian, domain.NewsEditor}), usersHandler.AuthorizeUser)
	// ---- Users
	r.POST("/users", authMiddleware.AuthorizeJWT([]string{domain.Admin}), encryptionMiddleware.DecryptData, usersHandler.CreateNewUser)
	r.GET("/users", authMiddleware.AuthorizeJWT([]string{domain.Admin}), usersHandler.FetchAllUsers)
	r.DELETE("/users/:id", authMiddleware.AuthorizeJWT([]string{domain.Admin}), usersHandler.DeleteUser)
	// ---- News
	r.GET("/news/number", cacheMiddleware, newsHandler.GetNumber)
	r.GET("/news", cacheMiddleware, newsHandler.Get)
	r.POST("/news", authMiddleware.AuthorizeJWT([]string{domain.Admin, domain.NewsEditor}), newsHandler.PostNewNews)
	r.PATCH("/news/:id", authMiddleware.AuthorizeJWT([]string{domain.Admin, domain.NewsEditor}), newsHandler.UpdateNews)
	r.DELETE("/news/:id", authMiddleware.AuthorizeJWT([]string{domain.Admin, domain.NewsEditor}), newsHandler.DeleteNews)
	r.GET("/news/:id", cacheMiddleware, newsHandler.GetDesc)
	// ---- Agrarian
	r.POST("/fields", authMiddleware.AuthorizeJWT([]string{domain.Admin}), fieldsHandler.PostParcelsAndEnclosures)
	r.GET("/fields/refs", authMiddleware.AuthorizeJWT([]string{domain.Admin}), fieldsHandler.GetParcelRefs)
	r.PATCH("/fields/refs", authMiddleware.AuthorizeJWT([]string{domain.Admin}), fieldsHandler.PostParcelRefs)
	r.GET("/fields", authMiddleware.AuthorizeJWT([]string{domain.Admin, domain.Agrarian}), fieldsHandler.GetParcelsByUser)

	return r
}

func setUpEnv() {
	err := error(nil)
	switch os.Getenv("ENV_MODE") {
	case "DOCKER":
		return
	case "PROD":
		err = godotenv.Load("../../../secrets/.env.production")
	case "DEV":
		err = godotenv.Load("../../../secrets/.env.development")
	default:
		err = godotenv.Load("../../../secrets/.env.local")
	}
	if err != nil {
		log.Fatal("Error loading .env file")
	}
}

func main() {

	setUpEnv()

	docs.SwaggerInfo.Title = "Agrarian exploitation Swagger API"
	docs.SwaggerInfo.Description = "This is an agrarian exploitation server."
	docs.SwaggerInfo.Version = "1.0"
	docs.SwaggerInfo.Host = "agrarian.swagger.io"
	docs.SwaggerInfo.BasePath = "/v2"
	docs.SwaggerInfo.Schemes = []string{"http", "https"}

	r := setupRouter()
	// m := setUpMonitoring(r)
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	port := os.Getenv("PORT")

	if port == "" {
		port = "8080"
	}
	// go func() {
	// 	_ = m.Run(":9090")
	// }()
	r.Run(":" + port)
}
